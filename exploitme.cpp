#include <errno.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

class ConnectionHandler {
public:
    ConnectionHandler(int fd) : _fd(fd) {}
    ~ConnectionHandler() { close(_fd); }

    int run() {
        while (true) {
            ssize_t bytes = recv(_fd, _recvBuffer + _recvBytes, sizeof(_recvBuffer), 0);
            if (bytes <= 0) {
                break;
            }
            _recvBytes += bytes;
            void* newline = memchr(_recvBuffer, '\n', _recvBytes);
            if (newline) {
                send(_fd, _recvBuffer, (char*)newline - _recvBuffer + 1, 0);
                break;
            }
        }
        return 0;
    }

private:
    int _fd = 0;
    char _recvBuffer[512];
    size_t _recvBytes = 0;
};

int main(int argc, const char* argv[]) {
    auto s = socket(AF_INET, SOCK_STREAM, 0);

    sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_addr.s_addr = INADDR_ANY;
    serverAddress.sin_port = htons(2000);
    
    if (bind(s, (sockaddr*)&serverAddress, sizeof(serverAddress)) < 0) {
        fprintf(stderr, "bind error (errno = %d)\n", errno);
        close(s);
        return 1;
    }
    
    if (listen(s, 5) < 0) {
        fprintf(stderr, "listen error (errno = %d)\n", errno);
        close(s);
        return 1;
    }
    
    printf("listening...\n");
    
    while (true) {
        sockaddr_storage clientAddress;
        socklen_t clientAddressLength = 0;
        auto fd = accept(s, (sockaddr*)&clientAddress, &clientAddressLength);
        if (fd < 0) {
            fprintf(stderr, "accept error (errno = %d)\n", errno);
            close(s);
            return 1;
        }
        if (!fork()) {
            close(s);
            ConnectionHandler handler(fd);
            return handler.run();
        }
        close(fd);
    }

    close(s);
    return 0;
}